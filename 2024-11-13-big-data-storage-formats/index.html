<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sean Davis, MD, PhD">

<title>Lightweight Comparative Analysis of Data Formats â€“ Talks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5462d0dc975739fea4b7814f85fabdb2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-KLLV1GCF4E"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-KLLV1GCF4E', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Talks</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#a-comparative-analysis-of-data-formats-zarr-hdf5-tiledb-parquet-and-arrow" id="toc-a-comparative-analysis-of-data-formats-zarr-hdf5-tiledb-parquet-and-arrow" class="nav-link active" data-scroll-target="#a-comparative-analysis-of-data-formats-zarr-hdf5-tiledb-parquet-and-arrow">A Comparative Analysis of Data Formats: Zarr, HDF5, TileDB, Parquet, and Arrow</a>
  <ul class="collapse">
  <li><a href="#zarr-the-cloud-native-array-specialist" id="toc-zarr-the-cloud-native-array-specialist" class="nav-link" data-scroll-target="#zarr-the-cloud-native-array-specialist">Zarr: The Cloud-Native Array Specialist</a></li>
  <li><a href="#hdf5-the-veteran-of-data-storage" id="toc-hdf5-the-veteran-of-data-storage" class="nav-link" data-scroll-target="#hdf5-the-veteran-of-data-storage">HDF5: The Veteran of Data Storage</a></li>
  <li><a href="#tiledb-the-array-database-powerhouse" id="toc-tiledb-the-array-database-powerhouse" class="nav-link" data-scroll-target="#tiledb-the-array-database-powerhouse">TileDB: The Array Database Powerhouse</a></li>
  <li><a href="#parquet-the-columnar-storage-champion-for-analytics" id="toc-parquet-the-columnar-storage-champion-for-analytics" class="nav-link" data-scroll-target="#parquet-the-columnar-storage-champion-for-analytics">Parquet: The Columnar Storage Champion for Analytics</a></li>
  <li><a href="#arrow-the-in-memory-accelerator" id="toc-arrow-the-in-memory-accelerator" class="nav-link" data-scroll-target="#arrow-the-in-memory-accelerator">Arrow: The In-Memory Accelerator</a></li>
  <li><a href="#feature-comparison-and-choosing-the-right-format" id="toc-feature-comparison-and-choosing-the-right-format" class="nav-link" data-scroll-target="#feature-comparison-and-choosing-the-right-format">Feature Comparison and Choosing the Right Format</a></li>
  </ul></li>
  <li><a href="#sparse-data-handling-a-critical-comparison" id="toc-sparse-data-handling-a-critical-comparison" class="nav-link" data-scroll-target="#sparse-data-handling-a-critical-comparison">Sparse Data Handling: A Critical Comparison</a></li>
  <li><a href="#r-and-python-packages-for-data-formats" id="toc-r-and-python-packages-for-data-formats" class="nav-link" data-scroll-target="#r-and-python-packages-for-data-formats">R and Python Packages for Data Formats</a></li>
  <li><a href="#notable-genomics-and-bioinformatics-projects-using-data-formats" id="toc-notable-genomics-and-bioinformatics-projects-using-data-formats" class="nav-link" data-scroll-target="#notable-genomics-and-bioinformatics-projects-using-data-formats">Notable Genomics and Bioinformatics Projects using Data Formats</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lightweight Comparative Analysis of Data Formats</h1>
<p class="subtitle lead">Zarr, HDF5, TileDB, Parquet, and Arrow</p>
  <div class="quarto-categories">
    <div class="quarto-category">Data Science</div>
    <div class="quarto-category">Bioinformatics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sean Davis, MD, PhD </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Wednesday, November 13, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="a-comparative-analysis-of-data-formats-zarr-hdf5-tiledb-parquet-and-arrow" class="level2">
<h2 class="anchored" data-anchor-id="a-comparative-analysis-of-data-formats-zarr-hdf5-tiledb-parquet-and-arrow">A Comparative Analysis of Data Formats: Zarr, HDF5, TileDB, Parquet, and Arrow</h2>
<p>The increasing volume and complexity of data in modern applications necessitate efficient and adaptable storage solutions. Choosing the right data format significantly impacts storage costs, query performance, and overall efficiency. This analysis provides a comprehensive comparison of five prominent data formats: Zarr, HDF5, TileDB, Parquet, and Arrow, delving into their technical features, strengths, weaknesses, and ideal use cases.</p>
<section id="zarr-the-cloud-native-array-specialist" class="level3">
<h3 class="anchored" data-anchor-id="zarr-the-cloud-native-array-specialist">Zarr: The Cloud-Native Array Specialist</h3>
<p>Zarr is a relatively new format designed for storing chunked, compressed, N-dimensional arrays. Its primary strength lies in its cloud-native nature, making it ideal for storing and processing large datasets in cloud environments. Zarr achieves this through its chunked structure, which allows for parallel reads and writes, enabling efficient distributed computing. Data is divided into smaller chunks, and each chunk can be compressed independently using algorithms like Zlib or Blosc. This not only reduces storage costs but also facilitates parallel processing, as different chunks can be read or written concurrently by multiple processes or machines. Zarr also provides a mechanism for consolidating small chunks into larger ones, improving read performance for certain access patterns. Metadata in Zarr is stored using JSON or YAML, ensuring interoperability and ease of access.</p>
<p>Zarr has gained popularity within the scientific community, particularly in fields like climate modeling and genomics, where large-scale datasets are commonplace. Its integration with Python libraries like Xarray and Dask further enhances its appeal for scientific workflows. While Zarr is a powerful format for array data, its relative newness means it has a smaller community and fewer mature tools compared to more established formats like HDF5.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Chunking:</strong> Enables parallel I/O and efficient cloud storage.</li>
<li><strong>Compression:</strong> Supports various compression algorithms for reduced storage costs.</li>
<li><strong>Consolidation:</strong> Improves read performance by consolidating small chunks.</li>
<li><strong>Metadata:</strong> Uses JSON or YAML for metadata storage.</li>
<li><strong>Programming Language Support:</strong> Primarily Python, with growing support in other languages.</li>
</ul>
</section>
<section id="hdf5-the-veteran-of-data-storage" class="level3">
<h3 class="anchored" data-anchor-id="hdf5-the-veteran-of-data-storage">HDF5: The Veteran of Data Storage</h3>
<p>HDF5 (Hierarchical Data Format) is a mature and widely used format for storing large, complex, and heterogeneous data. Its hierarchical structure, similar to a file system, allows for organizing data into groups and datasets, providing a flexible and organized approach to data management. HDF5 supports a wide range of datatypes, including primitive types, compound types, and user-defined types, making it suitable for diverse data structures. Attributes can be attached to groups and datasets to store metadata, providing context and enriching the data.</p>
<p>HDF5 has a long history and extensive libraries in various programming languages, including the HDF5 C library and h5py for Python. Its maturity and wide adoption make it a reliable choice for applications requiring a robust and versatile data format. However, while HDF5 can be used with cloud storage, itâ€™s not as inherently optimized for it as Zarr. Its flexibility can also lead to complexity, making it potentially more challenging to learn and use.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Hierarchical structure:</strong> Organizes data into groups and datasets.</li>
<li><strong>Diverse datatypes:</strong> Supports various datatypes, including user-defined types.</li>
<li><strong>Attributes:</strong> Allows attaching metadata to groups and datasets.</li>
<li><strong>Extensive libraries:</strong> Available in many programming languages, including C, C++, Java, Python, and Fortran.</li>
</ul>
</section>
<section id="tiledb-the-array-database-powerhouse" class="level3">
<h3 class="anchored" data-anchor-id="tiledb-the-array-database-powerhouse">TileDB: The Array Database Powerhouse</h3>
<p>TileDB is a unique offering in this comparison as itâ€™s not just a file format but a database specifically designed for storing and querying large, multi-dimensional array data. Its core strength lies in its efficiency for array-based data, particularly for scientific and geospatial applications. TileDB employs a tiling scheme where arrays are divided into tiles, optimizing I/O operations and query performance. It efficiently handles sparse arrays, where many elements are empty, by only storing non-empty values, which significantly reduces storage costs and improves query speed for sparse data.</p>
<p>TileDB is built with cloud-native principles and seamlessly integrates with cloud storage systems. It also provides advanced features like versioning, enabling efficient tracking of changes to the data without rewriting entire files. While TileDB excels at array data, its specialization might make it less suitable for general-purpose data storage where diverse data structures are required.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Tiling:</strong> Optimizes I/O and queries for array data.</li>
<li><strong>Sparse array support:</strong> Efficiently handles sparse arrays by storing only non-empty values.</li>
<li><strong>Key-value metadata:</strong> Supports rich metadata for added context.</li>
<li><strong>Versioning:</strong> Tracks changes to the data efficiently.</li>
<li><strong>Programming Language Support:</strong> C++, Python, Java, with integrations for R and Go.</li>
</ul>
</section>
<section id="parquet-the-columnar-storage-champion-for-analytics" class="level3">
<h3 class="anchored" data-anchor-id="parquet-the-columnar-storage-champion-for-analytics">Parquet: The Columnar Storage Champion for Analytics</h3>
<p>Parquet is a columnar storage format that has gained significant traction in the big data and analytics world. Its columnar layout, where data is stored by column instead of row, makes it highly efficient for analytical queries that typically involve reading only a subset of columns. This reduces I/O operations and speeds up query processing. Parquet also employs efficient compression techniques, further minimizing storage space. It supports nested data structures, allowing for complex data representation, and features schema evolution, enabling changes to the data schema over time without requiring rewriting existing data.</p>
<p>Parquet is well-integrated with popular big data processing frameworks like Apache Spark and Apache Hive, making it a staple in data warehousing and business intelligence applications. Its focus on analytical queries and columnar storage, however, makes it less suitable for applications requiring random access or those dealing with sparse data.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Columnar layout:</strong> Optimizes analytical queries by reducing I/O.</li>
<li><strong>Compression:</strong> Minimizes storage space.</li>
<li><strong>Nested data structures:</strong> Supports complex data representation.</li>
<li><strong>Schema evolution:</strong> Adapts to changes in data structure.</li>
<li><strong>Programming Language Support:</strong> Wide language support, including Java, Python, C++, and R, with integrations for various data processing frameworks.</li>
</ul>
</section>
<section id="arrow-the-in-memory-accelerator" class="level3">
<h3 class="anchored" data-anchor-id="arrow-the-in-memory-accelerator">Arrow: The In-Memory Accelerator</h3>
<p>Arrow is not just a file format but a comprehensive in-memory data format and processing framework. Its primary goal is to accelerate data transfer and processing by providing a standardized, language-agnostic, columnar format that enables efficient in-memory operations. Arrowâ€™s zero-copy sharing feature allows data to be shared between processes without the overhead of copying, significantly boosting performance in data analysis and inter-process communication.</p>
<p>Arrow has language bindings for a wide range of programming languages, including Python, R, Java, and C++, facilitating data sharing and interoperability between different systems. While Arrow can be used for on-disk storage, its main strength lies in its in-memory capabilities, making it a crucial component in data analysis, data science, and high-performance computing.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Columnar layout:</strong> Efficient for in-memory processing.</li>
<li><strong>Zero-copy sharing:</strong> Accelerates data transfer between processes.</li>
<li><strong>Language bindings:</strong> Provides libraries for various programming languages.</li>
<li><strong>Integration with data processing systems:</strong> Used in Apache Spark, Pandas, and other data processing systems.</li>
</ul>
</section>
<section id="feature-comparison-and-choosing-the-right-format" class="level3">
<h3 class="anchored" data-anchor-id="feature-comparison-and-choosing-the-right-format">Feature Comparison and Choosing the Right Format</h3>
<p>To further aid in understanding the differences between these formats, a feature comparison table is provided below:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Zarr</th>
<th>HDF5</th>
<th>TileDB</th>
<th>Parquet</th>
<th>Arrow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Primary Data Type</td>
<td>Array</td>
<td>Diverse</td>
<td>Array</td>
<td>Table</td>
<td>Array</td>
</tr>
<tr class="even">
<td>Chunking/Tiling</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Compression</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td>Cloud-Native</td>
<td>Yes</td>
<td>Limited</td>
<td>Yes</td>
<td>Limited</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Parallel I/O</td>
<td>Yes</td>
<td>Limited</td>
<td>Yes</td>
<td>Limited</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Querying</td>
<td>Basic</td>
<td>Basic</td>
<td>Advanced</td>
<td>Advanced</td>
<td>Basic</td>
</tr>
<tr class="odd">
<td>Versioning</td>
<td>Limited</td>
<td>Limited</td>
<td>Yes</td>
<td>Limited</td>
<td>No</td>
</tr>
<tr class="even">
<td>In-Memory</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Language Support</td>
<td>Primarily Python</td>
<td>Diverse</td>
<td>C++, Python, Java</td>
<td>Diverse</td>
<td>Diverse</td>
</tr>
<tr class="even">
<td>Sparse Data Support</td>
<td>Limited</td>
<td>Limited</td>
<td><strong>Excellent</strong></td>
<td>Limited</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>Selecting the optimal data format requires careful consideration of several factors:</p>
<ul>
<li><strong>Data structure:</strong> The type of data being stored (arrays, tables, complex objects).</li>
<li><strong>Data size and access patterns:</strong> The scale of the data and how it will be accessed (random access, analytical queries).</li>
<li><strong>Storage environment:</strong> Where the data will be stored (cloud storage, local file system).</li>
<li><strong>Performance needs:</strong> Requirements for I/O performance and in-memory processing.</li>
<li><strong>Integration with existing tools and libraries:</strong> Compatibility with existing workflows and tools.</li>
</ul>
<p>Youâ€™re absolutely correct! Handling sparse data efficiently is a critical consideration in many applications. Letâ€™s add a section dedicated to this aspect:</p>
</section>
</section>
<section id="sparse-data-handling-a-critical-comparison" class="level2">
<h2 class="anchored" data-anchor-id="sparse-data-handling-a-critical-comparison">Sparse Data Handling: A Critical Comparison</h2>
<p>Sparse data, where a large proportion of data points are missing or zero, presents unique challenges for storage and processing. Choosing a format optimized for sparsity can significantly impact storage costs, query performance, and overall efficiency. Hereâ€™s how the five formats handle sparse data:</p>
<p><strong>TileDB:</strong> TileDB stands out as the clear leader in sparse data handling. Its specialized storage engine is designed to efficiently store and query sparse arrays. TileDB only stores non-empty values, minimizing storage space and optimizing query performance for sparse data. Its ability to efficiently filter and retrieve non-empty values makes it a strong choice for applications with high sparsity, such as geospatial data, sparse matrices in scientific computing, and any application with large sparse arrays.</p>
<p><strong>Zarr and HDF5:</strong> Both Zarr and HDF5 offer limited support for sparse data. While they can store sparse matrices, their performance and efficiency may not be optimal compared to specialized formats like TileDB. Zarrâ€™s chunking with optional compression can help reduce storage size, but it doesnâ€™t provide explicit sparse encoding. HDF5 can store sparse matrices as compressed datasets, but itâ€™s not specifically optimized for sparsity. In both cases, careful optimization may be required to achieve reasonable performance with sparse data.</p>
<p><strong>Parquet and Arrow:</strong> Parquet and Arrow are not designed for sparse data storage. Parquetâ€™s columnar storage can be helpful in some cases, as it allows for efficient querying of specific columns, which can be beneficial for certain sparsity patterns. However, neither format is ideal for general sparse data. Arrow, being an in-memory format, is not intended for long-term storage of sparse data.</p>
<p><strong>Key Takeaways:</strong></p>
<ul>
<li>TileDB is the preferred choice for efficient sparse data handling due to its specialized storage engine and optimized querying capabilities.</li>
<li>Zarr and HDF5 offer limited support, and careful optimization may be necessary to achieve good performance.</li>
<li>Parquet and Arrow are not designed for sparse data and are better suited for dense data structures.</li>
</ul>
<p>You got it! Hereâ€™s a breakdown of R and Python packages for those data formats, along with some notable genomics/bioinformatics projects using them.</p>
</section>
<section id="r-and-python-packages-for-data-formats" class="level2">
<h2 class="anchored" data-anchor-id="r-and-python-packages-for-data-formats">R and Python Packages for Data Formats</h2>
<p><strong>R Packages</strong></p>
<ul>
<li><strong>Zarr:</strong>
<ul>
<li><code>zarr</code>: Provides a comprehensive interface for working with Zarr arrays in R.</li>
</ul></li>
<li><strong>HDF5:</strong>
<ul>
<li><code>rhdf5</code>: The standard package for reading and writing HDF5 files in R.</li>
<li><code>BiocHDF5</code>: A Bioconductor package specifically designed for handling HDF5 files in bioinformatics contexts.</li>
</ul></li>
<li><strong>TileDB:</strong>
<ul>
<li><code>tiledb</code>: Offers bindings to the TileDB C++ API, enabling access to TileDB arrays from R.</li>
</ul></li>
<li><strong>Parquet:</strong>
<ul>
<li><code>arrow</code>: The <code>arrow</code> package in R provides read and write support for Parquet files.</li>
<li><code>sparklyr</code>: If youâ€™re using Spark, <code>sparklyr</code> allows you to interact with Parquet files within a Spark context.</li>
</ul></li>
<li><strong>Arrow:</strong>
<ul>
<li><code>arrow</code>: Provides a complete implementation of the Arrow format in R, enabling efficient data transfer and in-memory processing.</li>
</ul></li>
</ul>
<p><strong>Python Packages</strong></p>
<ul>
<li><strong>Zarr:</strong>
<ul>
<li><code>zarr</code>: The primary package for working with Zarr arrays in Python. Integrates well with libraries like Xarray and Dask.</li>
</ul></li>
<li><strong>HDF5:</strong>
<ul>
<li><code>h5py</code>: The standard Pythonic interface to the HDF5 C library.</li>
</ul></li>
<li><strong>TileDB:</strong>
<ul>
<li><code>tiledb</code>: Python bindings for the TileDB C++ API, allowing access to TileDB arrays.</li>
</ul></li>
<li><strong>Parquet:</strong>
<ul>
<li><code>pyarrow</code>: The Python implementation of the Arrow format, including support for reading and writing Parquet files.</li>
<li><code>pandas</code>: The popular data manipulation library can read and write Parquet files.</li>
<li><code>dask</code>: For parallel and distributed computing, Dask can handle large Parquet datasets.</li>
</ul></li>
<li><strong>Arrow:</strong>
<ul>
<li><code>pyarrow</code>: The core Arrow library for Python, providing in-memory data structures and interoperability with other systems.</li>
</ul></li>
</ul>
</section>
<section id="notable-genomics-and-bioinformatics-projects-using-data-formats" class="level2">
<h2 class="anchored" data-anchor-id="notable-genomics-and-bioinformatics-projects-using-data-formats">Notable Genomics and Bioinformatics Projects using Data Formats</h2>
<ul>
<li><strong>Zarr:</strong>
<ul>
<li><strong>Single-cell RNA sequencing analysis:</strong> Zarr is increasingly used for storing and analyzing large single-cell datasets due to its scalability and cloud compatibility. Projects like <code>anndata</code> (Python) and <code>Seurat</code> (R) are starting to integrate with Zarr.</li>
<li><strong>Genomic variant data:</strong> Zarr is being explored as a format for storing and querying genomic variant data, potentially offering advantages over traditional VCF files.</li>
</ul></li>
<li><strong>HDF5:</strong>
<ul>
<li><strong>1000 Genomes Project:</strong> Uses HDF5 to store vast amounts of genomic data.</li>
<li><strong>Bioconductor:</strong> Many Bioconductor packages use HDF5 for storing and accessing bioinformatics data.</li>
</ul></li>
<li><strong>TileDB:</strong>
<ul>
<li><strong>Human Cell Atlas:</strong> Uses TileDB to store and query spatial transcriptomics data.</li>
<li><strong>GDC (Genomic Data Commons):</strong> Exploring TileDB for managing and accessing cancer genomics data.</li>
</ul></li>
<li><strong>Parquet:</strong>
<ul>
<li><strong>VariantSpark:</strong> A project using Spark and Parquet for large-scale genomic variant analysis.</li>
</ul></li>
<li><strong>Arrow:</strong>
<ul>
<li><strong>Genomic data analysis pipelines:</strong> Arrow is used in bioinformatics pipelines to accelerate data transfer and processing between different tools and stages.</li>
</ul></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/seandavi\.github\.io\/talks\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>